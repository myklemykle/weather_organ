//##################################### morenoises.lib ########################################
// Expanded noises library.  Unofficial prefix is `mn`.
//########################################################################################
ma = library("maths.lib");
ba = library("basics.lib");
os = library("oscillators.lib");
no = library("noises.lib"); 

declare name "Experimental Noise Generator Library";
declare author "Mykle James Hansen";
declare copyright "(c) Mykle James Hansen 2018";
declare version "0.5";
declare license "This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.";

// Normalizing coefficients for noise generators:
//
// The various noise generators in both this library and noises.lib
// have ideal properties relative to their own theories, but vary widely
// in absolute output level.  For situations where these noise sources
// are being interchanged or mixed, it's helpful to be able to normalize 
// each source to a constant 0db amplitude over a suitably wide average.
// TODO: obsole this when normailzing coeffients get added to the main libs.
normal = environment {
	no = environment { // noises.lib
		noise = 1;
		gnoise = 0.625; 
		pink_noise = 12.5;
		// pink_noise_vm(N) = 0*N + 0.275; // TODO: solve for N
		// TODO: velvet noise?
	};
	noise_pink = 0.312; 
	//noise_pink_n(N) = 0*N + 0.312; // TODO: solve for N
	noise_pink_sparse = 0.342; 
	// noise_pink_sparse_n(N) = 0*N + 0.312; // Unfinished. analyze & solve for N.
};
		

//-------------`(mn.sparse_periodic_trigger)`-----------------
// Emits +1 impulses ("trigger events") at an average frequency,
// with the distribution adjustable from purely periodic to purely random.
// 
// ### Usage
// ```
// sparse_periodic_trigger(f0, periodicity, pnoise) : _
// ```
//
// Where:
// 
// * `f0`: average number of triggers per second.
// * `periodicity`: coefficient of distribution noise.  0 <= periodicity <= 1.  0 = random distribution, 1 = regularly spaced pulses.
// * `pnoise`: random source of probability.  Pure white noise is good.
//----------------------------
sparse_periodic_trigger(f0, periodicity, noise) = 
	( 			
		+(rate)  							// add the rate;
		<: _, >=(1) 					// if greater than 1 ...
		: _, *(1+w*noise) : - // ... subtract 1+(w*noise) 
	) ~ _
	<: _, _' : <  			 		// emit 1 if the value decreased, 0 otherwise.
with { 
	w = max(0, min(1, 1 - periodicity));
	rate = f0/ma.SR;
};


//-------------`(mn.sparse_trigger)`-----------------
// Produce randomly spaced trigger events at an average frequency.
// 
// ### Usage
//
// ```
// sparse_trigger(f0, pnoise) : _
// ```
//
// Where:
// 
// * `f0`: average number of impulses per second.
// * `pnoise`: random source of probability.  Pure white noise is good.
//-------------------------------------
sparse_trigger(f0, noise) = sparse_periodic_trigger(f0, 0, noise);



//------------`(mn.)noise_half`---------------
//------------`(mn.)noise_half_periodic`---------------
// Produce randomly-spaced half-impulses, at an average frequency.
// Each half-impulse is a single-sided sparse noise that doesn't return to zero;
// between events, a constant DC offset is held.
// Each event is a single change to a new amplitude.
//
// ### Usage
// ```
// noise_half(f0, pnoise, anoise) : _
// no.noise, no.gnoise(5) : noise_half(f0) : _
// no.noise <: noise_half(f0) : _
// ```
// Where:
// 
// * `f0`: average number of impulses per second.
// * `pnoise`: random source of probability.  Pure white noise is good.
// * `anoise`: source of amplitude.  Pure white noise, gaussian, or any signal.
//-----------------
noise_half(f0, pnoise, anoise) = anoise : ba.sAndH(sparse_trigger(f0, pnoise));
noise_half_periodic(f0, w, pnoise, anoise) = anoise : ba.sAndH(sparse_periodic_trigger(f0, w, pnoise'));


//-------------`(mn.wide_gate)`-----------------
//-------------`(mn.wide_hold_gate)`-----------------
// wide_gate() is a gate that opens when triggered, 
// and stays open for an adjustable duration after the trigger 
//
// wide_hold_gate() is similar, but instead of closing by going
// to zero, it holds the last input sample using ba.sAndH().
// 
// ### Usage
//
// ```
// _ : wide_gate(trigger, width) : _
// _ : wide_hold_gate(trigger, width) : _
// ```
//
// Where:
// 
// * `trigger`: The gate opens when this goes nonzero, and starts counting down when this goes to zero.
// * `width`: duration (in seconds) of the countdown before gate is closed.
//
// #### See Also
// ba.sAndH
//-------------------------------------
wide_gate(trigger, seconds, signal) = ba.if(clock > 0, signal, 0)
with {
	width = seconds * ma.SR; 
	clock = max(width * (trigger != 0)) ~ (-(1) : max(0));
};

wide_hold_gate(trigger, seconds, signal) = ba.if(clock > 0, signal, signal:ba.sAndH(clock > 0) )
with {
	width = seconds * ma.SR; 
	clock = max(width * trigger) ~ (-(1) : max(0));
};



//-------------`(mn.noise_pink)`-----------------
//-------------`(mn.noise_pink_n)`-----------------
// Pink noise generator using Trammel's stochastic Voss/McCartney approach,
// intended to remove hi-freq ripple present in the standard V/M implementation.
// 
// Not drastically more useful than no.pink_noise_vm, and probably slower, 
// but presented for completeness. 
// ### Usage
//
// ```
// no.noise : noise_pink : _
// no.noise : noise_pink_n(N) : _
// ```
//
// Where:
// 
// * `N`: number of generators.  Integer, must be known at compile time. 
// Per the Voss McCartney algorithm, there is ideally one generator per audible octave in the frequencies below f0.
// noise_pink defaults to 10 generators, corresponding to 10 octaves within the frequencies of 20-20000hz.
// Lower values of N may be acceptable when the output is to be lowpass-filtered.
// Higher values of N & F0 and SR may be appropriate for UHF listeners (bats, dolphins, audiophiles, et cetera).
// 
//
// #### Reference:
// <http://www.ridgerat-tech.us/tech/pinkalg.htm>
//-------------------------------------
noise_pink_n(N) = noise_pink_sparse_n(N,ma.SR/2);
noise_pink = noise_pink_sparse_n(10, ma.SR/2);



//-------------`(mn.)noise_pink_sparse`-----------------
//-------------`(mn.)noise_pink_sparse_n`-----------------
// Sparse "pink" noise generator.  
//
// Not sure what to call this anymore, really.  The spectrum approaches pink (1/f) as 
// f0 approaches the sample rate; at that point, it's using noise_half() 
// to implement Trammel's "Stochastic Voss/McCartney" algorithm.
// However, at lower frequencies, the spectrum tilts toward brown (1/f^2).
// So it's cryptic and irregular ... but I like how it sounds.
//
// 
// ### Usage
//
// ```
// no.noise : noise_pink_sparse(f0) : _ 			
// no.noise : noise_pink_sparse_n(N, f0) : _ 
// ```
//
// Where:
// 
// * `f0`: average number of fluctuations per second.  
// Set this below 20 for sparse noise (individually perceptable noise events).  
// noise_pink() and noise_pink_n() set this to the highest value allowed by sample rate,
// to produce general-purpose pink noise.
// 
// * `N`: number of generators.  (Integer, must be known at compile time.)
// Per the Voss McCartney algorithm, pink noise wants one generator per audible octave in the frequencies below f0.
// noise_pink_sparse defaults to 10 generators, corresponding to 10 octaves within the frequencies of 20-20000hz.
// Lower values of N may be acceptable when f0 is low, or the output is to be lowpass-filtered.
// Higher values of N, f0 and ma.SR may be appropriate for UHF listeners (bats, dolphins, audiophiles, et cetera).
// 
// ### See Also:
// no.sparse_noise
// no.pink_noise_vm
//
// #### Reference:
// <http://www.ridgerat-tech.us/tech/pinkalg.htm>
//-------------------------------------
noise_pink_sparse_n(N, f0, noise) = noise, noise@N <: par(i, N, 
	@(i), @(i) : noise_half(F(i)) 
	) :> _
with {
  // Generator frequencies distributed exponentially between 0hz -> SR
  F(i) = ((2*f0) / (2^i)) ; 		// freq decreases with i.
};
noise_pink_sparse(f0, noise) = noise_pink_sparse_n(10, f0, noise);

